[{"content":"Why and What‚ÅâÔ∏è Ô∏èIn Software Development cycle, developers of every level have either heard or said the following:\nIt works on my machine, I am not sure why it isn\u0026rsquo;t running on yours\nDifferent software projects have different dependencies, that only keep going uphill as the product itself evolves. When this happens, we need to make sure all interactions between different components have been done correctly in order for the whole application to come together and run.\nThis is the very scenario where things can fall apart very easily!\nWhy Dockerü§î In scenarios like mentioned above, wouldn\u0026rsquo;t it be useful to have a tool that makes sure that a software is bundled in a way that is irrespective of the base dependencies it requires to be built on?\nAs I primarily work in Pythonüêç, I would like to throw in an analogy. This abstraction tool can be thought of like a virual environment, with each project having its own separate dependencies which do not interfere with a different project\u0026rsquo;s virtual environment, and every environment satisfying all the module level dependencies that the project needs.\nIn short, the tool that we need should have isolation and dependency matched as per the part of the project that is running on it!\nHaving such a tool to manage whole software, such that it handles all the base dependencies like that of the OS and any other package level dependencies are managed for us would be great, wouldn\u0026rsquo;t it?\nWhat is Dockerüê≥ In-line with the objectives that we want the above-mentioned tool to perform, let\u0026rsquo;s take a look at Docker.\nDocker helps abstract away the dependencies for components between varying OS, software, and hardware requirements, and lets every part of the project run in an isolated environment.\nFeels like technical mumbo jumbo? Well let\u0026rsquo;s take another go at understanding this. The abstraction that Docker provides can be thought of in the following way:\nImagine breaking the whole software into multiple smaller pieces, with each piece handling one part of some logic. This is what we call an isolated part of the project. Each part will naturally have a set of requirements in the forms of packages or configurations for it to be able to run correctly. This is the dependency that the project has. Running our project using Docker will abstract away the above said requirements for other people, and anybody running our project will use the configurations we have set when moving the project to Docker. I hope it is more or less clear what Docker does. If not, fret not! Things should become clearer as we go further with terminology.\nTerminologyüìñ So far, we have been trying to understand what Docker does in our own analogy and terms. However, things can go out of hand if one does not follow a standard terminologyüê±.\nLet\u0026rsquo;s dive in the terminology that will make our life easier to follow.\nObviously, one should at the end refer to the official glossary mentioned by Docker. However, to quickly get us started, I have mentioned some base terminologies below.\nDocker Image‚úíÔ∏è Since we need to create an isolated environment, we first need to decide what will the base of such an environment have. This base that each isolated environment needs is defined in a Docker image, which contains union of layered filesystems stacked on top of each other.\nWe can think of image as a small pre-compiled software on which we can run our assigned part of the project, and using an image is like installing Python or Ubuntu on your own machine.\nBecause of the awesome strength of the Docker community, they decided to keep a collection of the images that people need. This collection of images is listed on the Docker Hub, and we can find all sorts of images, like Alpine Linux and Python.\nNote: Although the Docker hub has many images readily available, we can also create our own Docker images. And as we read above that images are union of layered filesystems, our own image will also be a layer over some base image.\nA more detailed explanation of Docker Images is here.\nDocker Containerüì¶ So we saw that image in Docker is a base system that we want to run our piece of the project. When we run such an image, we get a Docker container.\nIn short, a Docker container is a running instance of a Docker image.\nA container always needs an image, and along with it, we sometimes pass a set of execution parameters such that the container has the parameters that we want, for example it\u0026rsquo;s name.\nA more detailed explanation of Docker containers is here.\nSumming it up!üí° What we saw so far is a very basic understanding of what Docker is, why we might need it, and what are the basic things we need to understand for breaking our project into small running containers. These small running containers can also be thought of as very small virtual machines, and this will be more clear when we look at the Docker Containers post. In the next part, let\u0026rsquo;s look at Docker Images in a bit more detail and how we can create our image. üò∫\n","permalink":"https://tanmaychimurkar.github.io/posts/docker/docker_intro/","summary":"Why and What‚ÅâÔ∏è Ô∏èIn Software Development cycle, developers of every level have either heard or said the following:\nIt works on my machine, I am not sure why it isn\u0026rsquo;t running on yours\nDifferent software projects have different dependencies, that only keep going uphill as the product itself evolves. When this happens, we need to make sure all interactions between different components have been done correctly in order for the whole application to come together and run.","title":"The basics of Docker to get started"},{"content":"Docker Imagesüê≥ As we saw in the basics of Docker post, the base flow of every Docker container is an image. A Docker image, whether custom or pre-built, is absolutely necessary for us to be able to run anything using Docker.\nIn essence, a Docker image is a union of layered filesystem stacked on top of each other. This stands true for pre-built images as well as custom images that we might create using some pre-built image as a base.\nTriviaüí°: If every Docker image is a set of layered instructions, then how is the first Docker image created? What did the very first Docker image have as a layer to be built on top of?\nHoping that the description of the Docker images is clear now, let\u0026rsquo;s now take a look at our first Docker image. And what better to look at than the image of Ubuntu itself!?!?\nDocker Image on Hub Use this link to navigate to the Docker Hub page of the Ubuntu image. Once there, go through the \u0026lsquo;What is Ubuntu?\u0026rsquo;, and \u0026lsquo;What\u0026rsquo;s in this image?\u0026rsquo; section. As you might have read, this image is Ubuntu. We can use this image for general purpose stuff on Ubuntu.\nNow let\u0026rsquo;s go to the \u0026lsquo;Tags\u0026rsquo; section on the webpage, and see what we find there. We can see that there many tags, and the first one that appears should have the TAG \u0026lsquo;Latest\u0026rsquo;, and on it\u0026rsquo;s right, there should be a command that says: docker pull ubuntu:latest. If we look at the next tag after Latest, notice how the docker pull command changes slightly with the name of the TAG that we are referring to! Also, take a look at the size of the image. It should be around 25-30 MB. WHATTTTTTT!!!! This means that the docker image that can run Ubuntu instructions is only 30 MB in size.üôÄ\nLet\u0026rsquo;s stop for a moment here and summarize what we have seen so far:\nDocker Hub has many pre-built images ready for us to explore Almost all the images have a description about what they are and a small summary of what they contain. Some have much greater description in terms of the Environment Variables, but let\u0026rsquo;s look at it later All the pre-built images on Docker Hub have Tags, and every tag is a version of the image Every image tag has a set of instructions about how to pull it. Let\u0026rsquo;s understand what the pull command does!üêï\nDocker Pullüßó Seeing that we have a command linked to a image on Docker Hub, naturally the next step is to get our hands dirty. This helps me get out of my comfort zone, but also helps me bring a concept that I am trying to grasp much easier to understand. I hope this also works the same for youüêà\nImp. Noteüê≥: For getting our hands dirty here, it is advised to go through the installation of Docker Desktop. Personally, I like the Docker Engine with the compose tool more, but to begin with, either of the two installations should work fine.\nWith Docker installed on your system, let\u0026rsquo;s verify the docker version. This can be done by opening a terminal and typing:\ndocker --version If you see a message with version, then we are good to get into the fun part.\nIn the terminal, type the below command to check the current images that docker has on your machine:\ndocker images If you see nothing, or only see the hello-world image, then we are good to go. Let\u0026rsquo;s now run the command that we saw on Docker Hub page of Ubuntu:\ndocker pull ubuntu:latest Once you run this command, you should see something similar to this:\nlatest: Pulling from library/ubuntu 6e3729cf69e0: Pull complete Digest: sha256:27cb6e6ccef575a4698b66f5de06c7ecd61589132d5a91d098f7f3f9285415a9 Status: Downloaded newer image for ubuntu:latest docker.io/library/ubuntu:latest What docker pull does is it pulls the image from Docker Hub into your local machine. Once the above output is visible in the terminal, we can check the images again with docker images, and now we should see the ubuntu image with the latest tag in the terminal.\nThis is the way for us to pull pre-built images from Docker Hub\nDockerFileüê≥ Since Docker images are a union of layered filesystem stacked on top of each other, we can also build our own custom image that does something that we want by building it on top of another pre-built image. To build our own image, we first need to create a DockerFile, which is a configuration file that has commands that Docker uses to build our image. Let\u0026rsquo;s have a look at the terminology that the DockerFile has.\nTerminologyüìñ DockerFile is just a text document that contains a set of instructions in order that Docker has to execute to build our image. Let\u0026rsquo;s now look at some of the most used commands that we need to build our own Docker image, while the main list of commands is still available under DockerFile reference.\nFROM: This commands sets the base image that we want our own image to be built on top of. Every DockerFile should start with a FROM command, since every image is built on top of another image.\nRUN: As the name suggests, this command is used to execute a set of instructions on top of the base image that we use for our own custom image. RUN commands can be run in two ways: either in shell form, or in exec form, which means there are two ways to run commands for the RUN instruction. The shell form for RUN directly uses the instruction like RUN sh -c echo hello, while in the exec form, the same command would be run as RUN [\u0026quot;sh\u0026quot;, \u0026quot;-c\u0026quot;, \u0026quot;echo hello\u0026quot;]\nCOPY: This command is used to copy something from our project code inside the Docker image. The copy command needs a source location to copy from and a destination location to copy inside the Docker image.\nWORKDIR: Sets the current working directory for the Docker image, such that all the instructions that follow the after setting WORKDIR will be executed from that directory.\nCMD: This instruction is used to specify the default arguments that we want the Docker image to take when we run it. There can only be one CMD instruction in a DockerFile, and if we have multiple, then only the last one will be executed. CMD instruction works as setting default arguments when we want to run an image.\nENTRYPOINT: As CMD sets a default command, the ENTRYPOINT command can override it. However, how the command is overridden depends on the whether the shell form is used or the exec form is used. The most intuitive explanation of the interaction between CMD and ENTRYPOINT is in the Docker documentation\nWhew!!üòå That was a lot of terminology, and we have not even covered eveything from the DockerFile reference. However, we do not need to understand how each and every parameter works in order to get started. Instead, these are the most common commands that are usually inside a DockerFile while building custom images.\nLet\u0026rsquo;s now build our own Docker image by building a DockerFileü§©\nCreating a DockerFile‚úçÔ∏è If you have gone through the installation process of installing Docker, you might have come across the hello-world example of docker. But in our case, let\u0026rsquo;s redo the hello-world example in Python, but by building our own Docker image.\nFirst thing is to create a simple Python script by placing the following line inside:\nprint(f\u0026#39;Hello world from inside the Docker container!\u0026#39;) Next step is to copy the below code into a file and naming it Dockerfile:\nFROM python WORKDIR /usr/src/app COPY hello_world.py ./ CMD [\u0026#34;python\u0026#34;, \u0026#34;hello_world.py\u0026#34;] In this file, we can see the following thing:\nThe first command we write is the FROM instruction, with the python image being used. Note that if we do not mention a default tag, then the latest tag is taken as default. The second instruction is setting the WORKDIR, which is like navigating to the /usr/src/app directory inside the container. The third instruction is COPY, which selects the hello_world.py to the current working directory set by the WORKDIR command The last instruction is CMD, which sets the default command to run when the image is started as a container. Building your image‚öíÔ∏è Once the above file is created, navigate to the folder containing the file and build the image using the Dockerfile that we created in the step above. The build command is used to build an image from a particular Dockerfile by using all the instructions from inside the Dockerfile. The -t flag is used to give a name and a tag to our image, similar to the name and the tag we see on Docker Hub. Run the following command in the terminal where the Dockerfile is located:\ndocker build -t custom_image:latest . Once the above command is run, we should see something like this in the terminal:\nStep 1/4 : FROM python latest: Pulling from library/python f2f58072e9ed: Pull complete 5c8cfbf51e6e: Pull complete aa3a609d1579: Pull complete 094e7d9bb04e: Pull complete 2cbfd734f382: Pull complete aa86ac293d0f: Pull complete 4cffc9f44941: Pull complete ae2c75627c86: Pull complete 2d2b74d2f0f7: Pull complete Digest: sha256:11560799e4311fd5abcca7ace13585756d7222ce5471162cd78c78a4ecaf62bd Status: Downloaded newer image for python:latest ---\u0026gt; 539eccd5ee4e Step 2/4 : WORKDIR /usr/src/app ---\u0026gt; Running in a63f44fb58c6 Removing intermediate container a63f44fb58c6 ---\u0026gt; 266dd62fca08 Step 3/4 : COPY hello_world.py ./ ---\u0026gt; 016f934d50e5 Step 4/4 : CMD [\u0026#34;python\u0026#34;, \u0026#34;hello_world.py\u0026#34;] ---\u0026gt; Running in b38de1b256fa Removing intermediate container b38de1b256fa ---\u0026gt; 432ba341135f Successfully built 432ba341135f Successfully tagged custom_image:latest As we analyze the output of the build command, we can see the following things:\nEvery instruction starts with the Step comment, followed by the step number which is currently being executed. For example, in Step 1/4, we can see that the docker engine is pulling the image from the Docker Hub to our local machine. Every instruction that we provided in the Dockerfile is echoed first, followed by its execution hash. Once all the instructions are executed, we get the final message saying Successfully built \u0026lt;hash\u0026gt; and Successfully tagged custom_image:latest. This message means that our custom image is now built. [Bonus]Running your custom imageüèÉ Once the above commands are run in the order we specify, we can check the list of images we have on our local machine by running the following command in the terminal:\ndocker images Here, we should see our custom_image being listed amongst other images, if any. Now that we have built our custom image, it is time to run it. For now, let\u0026rsquo;s copy the following command in the terminal to run the image as a container (Don\u0026rsquo;t worry about the below line of code, we will look at it in the here):\ndocker run custom_image:latest Once we execute the above command, we should see our print message in the terminal: Hello world from inside the Docker container!\nCongratulations!!ü•≥üéâ You have successfully built your first custom image. You are already a Docker Pro!!ü§ì\nSumming Up!üí° We saw in this post how once can either pull images from the Docker Hub or create their own custom images, and run them from the terminal. The next post will now focus more on the later part of running the image once we have it on our machine.\nUntil then, Cheers!!üï∫üíÉ\n","permalink":"https://tanmaychimurkar.github.io/posts/docker/docker_images/","summary":"Docker Imagesüê≥ As we saw in the basics of Docker post, the base flow of every Docker container is an image. A Docker image, whether custom or pre-built, is absolutely necessary for us to be able to run anything using Docker.\nIn essence, a Docker image is a union of layered filesystem stacked on top of each other. This stands true for pre-built images as well as custom images that we might create using some pre-built image as a base.","title":"Docker Images and DockerFile"},{"content":"What are they? In the previous post, we saw how to find Docker images form the DockerHub, and also how to create our own Docker image that executes a function. In this post, we will go more over the execution part of Docker, mainly about how to run a Docker image as a container.\nDocker Containers are Docker images that become containers at run time. Docker containers are short pieces of software that runs an application quickly, as a lightweight standalone package. The containers need an engine to run, and this is the Docker Engine.\nBasically, Docker containers make it easier to decentralize a large piece of software such that it can run in isolated environments, and they are what we can refer to as microservices. So in this part of the post, we will be running our first use case of microservices. We will start with running a single Docker image first, then we will combine many Docker images to run together so that they can interact with each other and run the whole software.\nRunning a Container In the previous post, we saw how we can either pull a pre-built Docker image from the DockerHub, or create our own custom image. We saw at the end that we had to run a specific command in the terminal to get the output from a Docker image. The commands that we ran in the previous post ran the Docker image, and during runtime, it created a Docker container that runs the piece of code that we put inside our own image or the outputs from a pre-built image from the DockerHub.\nIf you followed along with the previous post, you should now see the Ubuntu image in the terminal when you execute the below command in your terminal.\n\u0026gt; docker images REPOSITORY TAG IMAGE ID CREATED SIZE custom_image latest 432ba341135f 4 weeks ago 932MB ubuntu latest 6b7dfa7e8fdb 5 weeks ago 77.8MB In case you did not follow the previous post, we can run the following command in the terminal first to pull a Docker image and then continue:\ndocker pull ubuntu:latest Now we are ready to proceed. To start the Docker container, we can start by typing the following command in the terminal\ndocker run ubuntu If all is correct, you should see, well nothing. But why is that? We just ran our Ubuntu image as a Docker container, but we don\u0026rsquo;t see anything on the terminal when we run it.\ndocker ps command To check whether a particular image is successfully run or not, we need to execute the following command in the terminal:\ndocker ps The docker ps command lists all the containers. So if you ran the Ubuntu image as per the previous step, then the docker ps command should show that the Ubuntu container is running. Let\u0026rsquo;s try to check if that is the case. In the terminal, execute the following command:\ndocker ps However, the output we see in the terminal should be the following:\n\u0026gt; docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES Hmm, weird right? The documentation says that the docker ps command gives us a list of the containers. But we do not see anything in the terminal. This is because the docker ps command only list the containers that are running by default. And for our Ubuntu image, we did not give any specific command to run when we started the container via the docker run command. Which is why it is not showing up under the docker ps command. To check if the container was ranning when we started it, we need to pass the -a flag to the docker ps command. Let\u0026rsquo;s run the following command in the terminal to check this:\n\u0026gt; docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4c42acd7b1cd ubuntu \u0026#34;bash\u0026#34; 10 minutes ago Exited (0) 10 minutes ago condescending_villani We should see something like above in the terminal, with a different string under the NAMES and the CONTAINER ID column. Let\u0026rsquo;s see what terms shown in the output of the docker ps -a command mean.\nBelow is a list explaining what each of the terms given in the output above mean:\nCONTAINER ID: This column lists the id that a Docker container is given when it is run. This is a random id that is generated everytime a Docker container is run. If we run the same Docker image multiple times to start containers, it is very unlikely that the CONTAINER ID will be the same across different containers. IMAGE: This column gives the name of the Docker image that was used to start the Docker container. In our case, since we started the container using the command docker run ubuntu in the terminal, the IMAGE section correctly lists the ubuntu image in its run. COMMAND: This column lists the default command that is run when the Docker container is started. Since for the case of the ubuntu container, we did not specify any command, a default bash command is run on startup. CREATED: This field mentions the time when the container is started. STATUS: This field gives us a status of the container. In our case, we see the status code as being Exited (0) 10. This signifies that the ubuntu container was started, and is now shut down and is not running. The STATUS field helps us figure out the current status of a Docker container once it is started, and it can take different values, ranging from Creating ... to Up ..., which indicates that the container is either starting up or it is running for the amount of time mentioned after the Up string, respectively. PORTS: This field gives a list of ports that are to be exposed from inside the Docker container to the local user\u0026rsquo;s machine, so that the local user can access the port outside of Docker\u0026rsquo;s network NAMES: This field outputs the name that the docker container has when it is running. The name of a Docker container when it is run is also generated at random everytime a Docker container is started, but unlike the CONTAINER ID field, the name can be controlled and kept static for a particular Docker container. So, these are all the fields that are showed by the docker ps -a command. Now let\u0026rsquo;s start tampering with the docker run command to get a bit more out of the containers when we run them.\nPassing arguments to docker run command In the previous step, we just used the docker run command out of the box on the Ubuntu image. However, that did not give us much, not even a friendly terminal to let us inside the container that is running. Let\u0026rsquo;s now try to get inside the Ubuntu container to check what it has.\nTo do this, we first need to make the Ubuntu container execute a different command at runtime when it is started. For this, we can pass additional arguments to the docker run command in the terminal as follows:\ndocker run ubuntu sleep 3600 The sleep command that we pass is not a Docker argument, but a Linux system argument.\nTip: You can check more about the sleep command by running man sleep in your terminal (Only works for Linux-based OS like Ubuntu or MacOS)\nThe sleep command will override the default bash command from the Ubuntu container, and make the container sleep for the 3600 seconds 60 minutes. That should give us enough time to check what is inside the container.\nSo, once we have run the above command, we should see that the terminal does not exit like in the initial docker run command, but is in a way just stuck. However, if you open a new terminal and list all the containers with docker ps -a, we should now see the following:\n\u0026gt; docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8ec5ceccbd72 ubuntu \u0026#34;sleep 3600\u0026#34; 3 seconds ago Up 1 second fervent_mclaren Notice how in the STATUS field it now shows Up 1 second. And also take a look COMMAND section to see that it now shows sleep 3600 as the command instead of bash like the previous case. That means the command that we passed while starting the container worked, and is executed as soon as the Ubuntu container is started. Let us now see what is inside the Ubuntu container.\nGoing inside a running container Now that the ubuntu container is running, we can look inside it. The default method to look what is inside a container is to get a terminal, and we can do the same for the ubuntu container. To get a terminal inside the container, we can run the following command:\n\u0026gt; docker exec -it \u0026lt;identifier\u0026gt; The exec command is used to run a command inside a running container. And to let Docker know which container we want to choose to execute the command, we need to pass an \u0026lt;identifier\u0026gt; above, which can either be the NAME of the container or the CONTAINER ID. Let\u0026rsquo;s pass the CONTAINER ID for now, but we can pass NAME in exactly the same way.\nPro Tip: For passing the CONTAINER ID as an identifier for the exec command, we do not need to pass the full container id. Instead, we can just pass the first 3 characters of the CONTAINER ID to the exec command, and it will still be executed inside the correct running container.\nTo execute and get a shell inside the running container, run the following command:\ndocker exec -it 8ec bash Please make sure to pass the correct first 3 characters from your CONTAINER ID, since every CONTAINER ID is randomly generated, and your CONTAINER ID will not be the same as mine.\nOnce we run the above command in a new terminal, we should see the following output:\n\u0026gt; docker exec -it 8ec bash root@8ec5ceccbd72:/# Well, well. We are now inside our running Docker container!!!üêï\nWe can now ls to check what files/directories the container has, and we can look around inside them as part of exploration. Let\u0026rsquo;s now see how we can give a name to a Docker container when we run it, and why is it useful.\nSome tips for running Docker containers It is very beneficial to give your Docker container a name, since doing so will always maintain a streamlined process of seeing inside the container and accessing it for checking your processes. This can be done by passing in the --name flag to the docker run command, which is a Docker flag unlike the sleep command we saw earlier. Let\u0026rsquo;s execute the following command in the terminal: docker run --name my_ubuntu_image ubuntu sleep 1000 You can pass either my_ubutu_image as the name of your container, or you can get creative and pass something that you like as a name for your Docker container. Once we run the above command, you can open a new terminal and check running containers with docker ps -a. Once you do, you should now see something like the following output:\n\u0026gt; docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f04164a6395f ubuntu \u0026#34;sleep 1000\u0026#34; 3 seconds ago Up 1 second my_ubuntu_image Notice how the docker container now has in the NAMES field the name my_ubuntu_image, or whatever name you passed along in the --name flag. Now if you want to exec inside the running container, instead of passing the CONTAINER ID, we can pass the name of the container and it will go inside. Let\u0026rsquo;s try this out with docker exec -it my_ubuntu_image bash to get bash inside the docker container. You should definitely see something like the following:\n\u0026gt; docker exec -it my_ubuntu_image bash root@f04164a6395f:/# Now we can always refer to our container while running commands with its name.\nNow that we have a Ubuntu container running, we need to know how to stop it. We need to stop old containers before running new ones, since Docker does not let us run two containers with the same name twice. To check this, run the following command again in a new terminal: docker run --name my_ubuntu_image ubuntu sleep 1000 You should get the following error message:\n\u0026gt; docker run --name my_ubuntu_image ubuntu docker: Error response from daemon: Conflict. The container name \u0026#34;/my_ubuntu_image\u0026#34; is already in use by container \u0026#34;f04164a6395f2c472bc5c6f6e59e304baa793b5d7edf106066e0764b51e1ad5d\u0026#34;. You have to remove (or rename) that container to be able to reuse that name. The error message tells us that there is a conflict with the container name, since we are already running a Ubuntu container with the same name. To rerun a new container with the same name, we first need to stop the one that is running currently. For this, we need to run the following command in a new terminal:\n\u0026gt; docker stop my_ubuntu_image Once you run this command, the terminal will be back after the command is executed successfully, and if you now get a list of all the containers, you should see the following:\n\u0026gt; docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f04164a6395f ubuntu \u0026#34;sleep 1000\u0026#34; 12 minutes ago Exited (137) 9 seconds ago my_ubuntu_image As you can see, the STATUS field now shows Exited ... under it instead of the previously shown Up for x seconds. This means that our Ubuntu container has stopped running, and we are ready to start another container with the same desired name.\nAs per the above step, you now know how to stop a docker container. However, if you run the container again, you will still get the same error message with the name conflict as before. That is because docker not only needs you to stop the container, but to completely remove it before starting a new container. To do this, we can run the following command in a new terminal: docker system prune You should then show the following prompt in your terminal window:\n\u0026gt; docker system prune WARNING! This will remove: - all stopped containers - all networks not used by at least one container - all dangling images - all dangling build cache Are you sure you want to continue? [y/N] docker system prune simply removes all the unnecessary data from your Docker environment, like stopped containers, containers that could not start correctly, or cache that a container created on your machine when it was started. In the above prompt, type y and press enter to let docker clear all stopped containers and the data related to them. Once this is successful, you should see a message as follows:\nDeleted Containers: f04164a6395f2c472bc5c6f6e59e304baa793b5d7edf106066e0764b51e1ad5d Total reclaimed space: 0B This message indicates that all the stopped containers are now removed, alongwith the caches that they had created when started. To check if there are any containers still, you can run docker ps -a.\nIf you want to manually remove only one specific container from the stopped containers afters stopping it, you can run the following command instead:\ndocker rm \u0026lt;container name or id\u0026gt; This will remove only the container whose name or id you passed.\nThe methodology of running containers from pre-built docker images can be extended to running custom images as containers that we create according to the previous post, or any custom container of your choice. All the list of commands remain the same, only the pre-built ubuntu image from the above commands needs to be replaced with your own custom image.\nRunning multiple containers and make them interact with each other So far, we have seen how to run a single image as a container, give it a name, pass some commands to override the default commands, how to stop and remove it. However, large pieces of software are rarely built on only one running container, and there are always many containers handling one specific task of the software independent of other tasks that are run by the software.\nFor this, we need to run multiple containers at once, and these containers also need to be able to interact with each other in order to make the software run successfully. Once simple examples where different containers can be run to do different tasks is run a PostgreSQL database to store some results from an API, a container to run the API itself, and a pgAdmin UI tool to interact with the database to check if the data that the API returns are being stored successfully inside the postgreSQL database. This sounds like a very general purpose use-case that many companies have in common, and this can be managed very efficiently via docker containers. We will see more about this in the next post of Docker Compose files, which allows us to run multiple containers at once.\n","permalink":"https://tanmaychimurkar.github.io/posts/docker/docker_compose/","summary":"What are they? In the previous post, we saw how to find Docker images form the DockerHub, and also how to create our own Docker image that executes a function. In this post, we will go more over the execution part of Docker, mainly about how to run a Docker image as a container.\nDocker Containers are Docker images that become containers at run time. Docker containers are short pieces of software that runs an application quickly, as a lightweight standalone package.","title":"Docker Compose"},{"content":"What is a Docker Container?üì¶ In the previous post, we saw how to find Docker images form the DockerHub, and also how to create our own Docker image that executes a function. In this post, we will go more over the execution part of Docker, mainly about how to run a Docker image as a container.\nDocker Containers are Docker images that become containers at run time. Docker containers are short pieces of software that runs an application quickly, as a lightweight standalone package. The containers need an engine to run, and this is the Docker Engine.\nBasically, Docker containers make it easier to decentralize a large piece of software such that it can run in isolated environments, and they are what we can refer to as microservices. So in this part of the post, we will be running our first use case of microservices. We will start with running a single Docker image first, then we will combine many Docker images to run together so that they can interact with each other and run the whole software.\nRunning a ContainerüèÉ In the previous post, we saw how we can either pull a pre-built Docker image from the DockerHub, or create our own custom image. We saw at the end that we had to run a specific command in the terminal to get the output from a Docker image. The commands that we ran in the previous post ran the Docker image, and during runtime, it created a Docker container that runs the piece of code that we put inside our own image or the outputs from a pre-built image from the DockerHub.\nIf you followed along with the previous post, you should now see the Ubuntu image in the terminal when you execute the below command in your terminal.\n\u0026gt; docker images REPOSITORY TAG IMAGE ID CREATED SIZE custom_image latest 432ba341135f 4 weeks ago 932MB ubuntu latest 6b7dfa7e8fdb 5 weeks ago 77.8MB In case you did not follow the previous post, we can run the following command in the terminal first to pull a Docker image and then continue:\ndocker pull ubuntu:latest Now we are ready to proceed. To start the Docker container, we can start by typing the following command in the terminal\ndocker run ubuntu If all is correct, you should see, well nothing. But why is that? We just ran our Ubuntu image as a Docker container, but we don\u0026rsquo;t see anything on the terminal when we run it.\ndocker ps command To check whether a particular image is successfully run or not, we need to execute the following command in the terminal:\ndocker ps The docker ps command lists all the containers. So if you ran the Ubuntu image as per the previous step, then the docker ps command should show that the Ubuntu container is running. Let\u0026rsquo;s try to check if that is the case. In the terminal, execute the following command:\ndocker ps However, the output we see in the terminal should be the following:\n\u0026gt; docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES Hmm, weird right? The documentation says that the docker ps command gives us a list of the containers. But we do not see anything in the terminal. This is because the docker ps command only list the containers that are running by default. And for our Ubuntu image, we did not give any specific command to run when we started the container via the docker run command. Which is why it is not showing up under the docker ps command. To check if the container was ranning when we started it, we need to pass the -a flag to the docker ps command. Let\u0026rsquo;s run the following command in the terminal to check this:\n\u0026gt; docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4c42acd7b1cd ubuntu \u0026#34;bash\u0026#34; 10 minutes ago Exited (0) 10 minutes ago condescending_villani We should see something like above in the terminal, with a different string under the NAMES and the CONTAINER ID column. Let\u0026rsquo;s see what terms shown in the output of the docker ps -a command mean.\nBelow is a list explaining what each of the terms given in the output above mean:\nCONTAINER ID: This column lists the id that a Docker container is given when it is run. This is a random id that is generated everytime a Docker container is run. If we run the same Docker image multiple times to start containers, it is very unlikely that the CONTAINER ID will be the same across different containers. IMAGE: This column gives the name of the Docker image that was used to start the Docker container. In our case, since we started the container using the command docker run ubuntu in the terminal, the IMAGE section correctly lists the ubuntu image in its run. COMMAND: This column lists the default command that is run when the Docker container is started. Since for the case of the ubuntu container, we did not specify any command, a default bash command is run on startup. CREATED: This field mentions the time when the container is started. STATUS: This field gives us a status of the container. In our case, we see the status code as being Exited (0) 10. This signifies that the ubuntu container was started, and is now shut down and is not running. The STATUS field helps us figure out the current status of a Docker container once it is started, and it can take different values, ranging from Creating ... to Up ..., which indicates that the container is either starting up or it is running for the amount of time mentioned after the Up string, respectively. PORTS: This field gives a list of ports that are to be exposed from inside the Docker container to the local user\u0026rsquo;s machine, so that the local user can access the port outside of Docker\u0026rsquo;s network NAMES: This field outputs the name that the docker container has when it is running. The name of a Docker container when it is run is also generated at random everytime a Docker container is started, but unlike the CONTAINER ID field, the name can be controlled and kept static for a particular Docker container. So, these are all the fields that are showed by the docker ps -a command. Now let\u0026rsquo;s start tampering with the docker run command to get a bit more out of the containers when we run them.\nPassing arguments to docker run command‚ÄºÔ∏è In the previous step, we just used the docker run command out of the box on the Ubuntu image. However, that did not give us much, not even a friendly terminal to let us inside the container that is running. Let\u0026rsquo;s now try to get inside the Ubuntu container to check what it has.\nTo do this, we first need to make the Ubuntu container execute a different command at runtime when it is started. For this, we can pass additional arguments to the docker run command in the terminal as follows:\ndocker run ubuntu sleep 3600 The sleep command that we pass is not a Docker argument, but a Linux system argument.\nTip: You can check more about the sleep command by running man sleep in your terminal (Only works for Linux-based OS like Ubuntu or MacOS)\nThe sleep command will override the default bash command from the Ubuntu container, and make the container sleep for the 3600 seconds 60 minutes. That should give us enough time to check what is inside the container.\nSo, once we have run the above command, we should see that the terminal does not exit like in the initial docker run command, but is in a way just stuck. However, if you open a new terminal and list all the containers with docker ps -a, we should now see the following:\n\u0026gt; docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8ec5ceccbd72 ubuntu \u0026#34;sleep 3600\u0026#34; 3 seconds ago Up 1 second fervent_mclaren Notice how in the STATUS field it now shows Up 1 second. And also take a look COMMAND section to see that it now shows sleep 3600 as the command instead of bash like the previous case. That means the command that we passed while starting the container worked, and is executed as soon as the Ubuntu container is started. Let us now see what is inside the Ubuntu container.\nGoing inside a running container Now that the ubuntu container is running, we can look inside it. The default method to look what is inside a container is to get a terminal, and we can do the same for the ubuntu container. To get a terminal inside the container, we can run the following command:\n\u0026gt; docker exec -it \u0026lt;identifier\u0026gt; The exec command is used to run a command inside a running container. And to let Docker know which container we want to choose to execute the command, we need to pass an \u0026lt;identifier\u0026gt; above, which can either be the NAME of the container or the CONTAINER ID. Let\u0026rsquo;s pass the CONTAINER ID for now, but we can pass NAME in exactly the same way.\nPro Tip: For passing the CONTAINER ID as an identifier for the exec command, we do not need to pass the full container id. Instead, we can just pass the first 3 characters of the CONTAINER ID to the exec command, and it will still be executed inside the correct running container.\nTo execute and get a shell inside the running container, run the following command:\ndocker exec -it 8ec bash Please make sure to pass the correct first 3 characters from your CONTAINER ID, since every CONTAINER ID is randomly generated, and your CONTAINER ID will not be the same as mine.\nOnce we run the above command in a new terminal, we should see the following output:\n\u0026gt; docker exec -it 8ec bash root@8ec5ceccbd72:/# Well, well. We are now inside our running Docker container!!!üêï\nWe can now ls to check what files/directories the container has, and we can look around inside them as part of exploration. Let\u0026rsquo;s now see how we can give a name to a Docker container when we run it, and why is it useful.\nSome tips for running Docker containersüí° It is very beneficial to give your Docker container a name, since doing so will always maintain a streamlined process of seeing inside the container and accessing it for checking your processes. This can be done by passing in the --name flag to the docker run command, which is a Docker flag unlike the sleep command we saw earlier. Let\u0026rsquo;s execute the following command in the terminal: docker run --name my_ubuntu_image ubuntu sleep 1000 You can pass either my_ubutu_image as the name of your container, or you can get creative and pass something that you like as a name for your Docker container. Once we run the above command, you can open a new terminal and check running containers with docker ps -a. Once you do, you should now see something like the following output:\n\u0026gt; docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f04164a6395f ubuntu \u0026#34;sleep 1000\u0026#34; 3 seconds ago Up 1 second my_ubuntu_image Notice how the docker container now has in the NAMES field the name my_ubuntu_image, or whatever name you passed along in the --name flag. Now if you want to exec inside the running container, instead of passing the CONTAINER ID, we can pass the name of the container and it will go inside. Let\u0026rsquo;s try this out with docker exec -it my_ubuntu_image bash to get bash inside the docker container. You should definitely see something like the following:\n\u0026gt; docker exec -it my_ubuntu_image bash root@f04164a6395f:/# Now we can always refer to our container while running commands with its name.\nNow that we have a Ubuntu container running, we need to know how to stop it. We need to stop old containers before running new ones, since Docker does not let us run two containers with the same name twice. To check this, run the following command again in a new terminal: docker run --name my_ubuntu_image ubuntu sleep 1000 You should get the following error message:\n\u0026gt; docker run --name my_ubuntu_image ubuntu docker: Error response from daemon: Conflict. The container name \u0026#34;/my_ubuntu_image\u0026#34; is already in use by container \u0026#34;f04164a6395f2c472bc5c6f6e59e304baa793b5d7edf106066e0764b51e1ad5d\u0026#34;. You have to remove (or rename) that container to be able to reuse that name. The error message tells us that there is a conflict with the container name, since we are already running a Ubuntu container with the same name. To rerun a new container with the same name, we first need to stop the one that is running currently. For this, we need to run the following command in a new terminal:\n\u0026gt; docker stop my_ubuntu_image Once you run this command, the terminal will be back after the command is executed successfully, and if you now get a list of all the containers, you should see the following:\n\u0026gt; docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f04164a6395f ubuntu \u0026#34;sleep 1000\u0026#34; 12 minutes ago Exited (137) 9 seconds ago my_ubuntu_image As you can see, the STATUS field now shows Exited ... under it instead of the previously shown Up for x seconds. This means that our Ubuntu container has stopped running, and we are ready to start another container with the same desired name.\nAs per the above step, you now know how to stop a docker container. However, if you run the container again, you will still get the same error message with the name conflict as before. That is because docker not only needs you to stop the container, but to completely remove it before starting a new container. To do this, we can run the following command in a new terminal: docker system prune You should then show the following prompt in your terminal window:\n\u0026gt; docker system prune WARNING! This will remove: - all stopped containers - all networks not used by at least one container - all dangling images - all dangling build cache Are you sure you want to continue? [y/N] docker system prune simply removes all the unnecessary data from your Docker environment, like stopped containers, containers that could not start correctly, or cache that a container created on your machine when it was started. In the above prompt, type y and press enter to let docker clear all stopped containers and the data related to them. Once this is successful, you should see a message as follows:\nDeleted Containers: f04164a6395f2c472bc5c6f6e59e304baa793b5d7edf106066e0764b51e1ad5d Total reclaimed space: 98B This message indicates that all the stopped containers are now removed, alongwith the caches that they had created when started. To check if there are any containers still, you can run docker ps -a.\nIf you want to manually remove only one specific container from the stopped containers afters stopping it, you can run the following command instead:\ndocker rm \u0026lt;container name or id\u0026gt; This will remove only the container whose name or id you passed.\nThe methodology of running containers from pre-built docker images can be extended to running custom images as containers that we create according to the previous post, or any custom container of your choice. All the list of commands remain the same, only the pre-built ubuntu image from the above commands needs to be replaced with your own custom image.\nRunning multiple containers and make them interact with each other So far, we have seen how to run a single image as a container, give it a name, pass some commands to override the default commands, how to stop and remove it. However, large pieces of software are rarely built on only one running container, and there are always many containers handling one specific task of the software independent of other tasks that are run by the software.\nFor this, we need to run multiple containers at once, and these containers also need to be able to interact with each other in order to make the software run successfully. Once simple examples where different containers can be run to do different tasks is run a PostgreSQL database to store some results from an API, a container to run the API itself, and a pgAdmin UI tool to interact with the database to check if the data that the API returns are being stored successfully inside the postgreSQL database. This sounds like a very general purpose use-case that many companies have in common, and this can be managed very efficiently via docker containers. We will see more about this in the next post of Docker Compose files, which allows us to run multiple containers at once.\n","permalink":"https://tanmaychimurkar.github.io/posts/docker/docker_containers/","summary":"What is a Docker Container?üì¶ In the previous post, we saw how to find Docker images form the DockerHub, and also how to create our own Docker image that executes a function. In this post, we will go more over the execution part of Docker, mainly about how to run a Docker image as a container.\nDocker Containers are Docker images that become containers at run time. Docker containers are short pieces of software that runs an application quickly, as a lightweight standalone package.","title":"Docker Containers"}]