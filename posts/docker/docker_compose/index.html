<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker Container and docker-compose | Tanmay's Blog</title><meta name=keywords content="Docker,microservices"><meta name=description content="This post goes over the usage of Docker container, how to run them, and how to create a compose file so that many Docker images can interact with each other"><meta name=author content="Tanmay"><link rel=canonical href=https://tanmaychimurkar.github.io/posts/docker/docker_compose/><link crossorigin=anonymous href=/assets/css/stylesheet.b183800e2cfbb62c3bce2b2ba56cdb2dd33af76c75cf4550173d5dfebd7c68a6.css integrity="sha256-sYOADiz7tiw7zisrpWzbLdM692x1z0VQFz1d/r18aKY=" rel="preload stylesheet" as=style><link rel=icon href=https://tanmaychimurkar.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://tanmaychimurkar.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://tanmaychimurkar.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://tanmaychimurkar.github.io/apple-touch-icon.png><link rel=mask-icon href=https://tanmaychimurkar.github.io/apple-touch-icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><meta property="og:title" content="Docker Container and docker-compose"><meta property="og:description" content="This post goes over the usage of Docker container, how to run them, and how to create a compose file so that many Docker images can interact with each other"><meta property="og:type" content="article"><meta property="og:url" content="https://tanmaychimurkar.github.io/posts/docker/docker_compose/"><meta property="og:image" content="https://diginomica.com/sites/default/files/images/2017-09/docker-container.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-10T04:17:32+00:00"><meta property="article:modified_time" content="2022-08-10T04:17:32+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://diginomica.com/sites/default/files/images/2017-09/docker-container.jpg"><meta name=twitter:title content="Docker Container and docker-compose"><meta name=twitter:description content="This post goes over the usage of Docker container, how to run them, and how to create a compose file so that many Docker images can interact with each other"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://tanmaychimurkar.github.io/posts/"},{"@type":"ListItem","position":3,"name":"Docker","item":"https://tanmaychimurkar.github.io/posts/docker/"},{"@type":"ListItem","position":4,"name":"Docker Container and docker-compose","item":"https://tanmaychimurkar.github.io/posts/docker/docker_compose/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker Container and docker-compose","name":"Docker Container and docker-compose","description":"This post goes over the usage of Docker container, how to run them, and how to create a compose file so that many Docker images can interact with each other","keywords":["Docker","microservices"],"articleBody":"What are they? In the previous post, we saw how to find Docker images form the DockerHub, and also how to create our own Docker image that executes a function. In this post, we will go more over the execution part of Docker, mainly about how to run a Docker image as a container.\nDocker Containers are Docker images that become containers at run time. Docker containers are short pieces of software that runs an application quickly, as a lightweight standalone package. The containers need an engine to run, and this is the Docker Engine.\nBasically, Docker containers make it easier to decentralize a large piece of software such that it can run in isolated environments, and they are what we can refer to as microservices. So in this part of the post, we will be running our first use case of microservices. We will start with running a single Docker image first, then we will combine many Docker images to run together so that they can interact with each other and run the whole software.\nRunning a Container In the previous post, we saw how we can either pull a pre-built Docker image from the DockerHub, or create our own custom image. We saw at the end that we had to run a specific command in the terminal to get the output from a Docker image. The commands that we ran in the previous post ran the Docker image, and during runtime, it created a Docker container that runs the piece of code that we put inside our own image or the outputs from a pre-built image from the DockerHub.\nIf you followed along with the previous post, you should now see the Ubuntu image in the terminal when you execute the below command in your terminal.\n\u003e docker images REPOSITORY TAG IMAGE ID CREATED SIZE custom_image latest 432ba341135f 4 weeks ago 932MB ubuntu latest 6b7dfa7e8fdb 5 weeks ago 77.8MB In case you did not follow the previous post, we can run the following command in the terminal first to pull a Docker image and then continue:\ndocker pull ubuntu:latest Now we are ready to proceed. To start the Docker container, we can start by typing the following command in the terminal\ndocker run ubuntu If all is correct, you should see, well nothing. But why is that? We just ran our Ubuntu image as a Docker container, but we don’t see anything on the terminal when we run it.\ndocker ps command To check whether a particular image is successfully run or not, we need to execute the following command in the terminal:\ndocker ps The docker ps command lists all the containers. So if you ran the Ubuntu image as per the previous step, then the docker ps command should show that the Ubuntu container is running. Let’s try to check if that is the case. In the terminal, execute the following command:\ndocker ps However, the output we see in the terminal should be the following:\n\u003e docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES Hmm, weird right? The documentation says that the docker ps command gives us a list of the containers. But we do not see anything in the terminal. This is because the docker ps command only list the containers that are running by default. And for our Ubuntu image, we did not give any specific command to run when we started the container via the docker run command. Which is why it is not showing up under the docker ps command. To check if the container was ranning when we started it, we need to pass the -a flag to the docker ps command. Let’s run the following command in the terminal to check this:\n\u003e docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 4c42acd7b1cd ubuntu \"bash\" 10 minutes ago Exited (0) 10 minutes ago condescending_villani We should see something like above in the terminal, with a different string under the NAMES and the CONTAINER ID column. Let’s see what terms shown in the output of the docker ps -a command mean.\nBelow is a list explaining what each of the terms given in the output above mean:\nCONTAINER ID: This column lists the id that a Docker container is given when it is run. This is a random id that is generated everytime a Docker container is run. If we run the same Docker image multiple times to start containers, it is very unlikely that the CONTAINER ID will be the same across different containers. IMAGE: This column gives the name of the Docker image that was used to start the Docker container. In our case, since we started the container using the command docker run ubuntu in the terminal, the IMAGE section correctly lists the ubuntu image in its run. COMMAND: This column lists the default command that is run when the Docker container is started. Since for the case of the ubuntu container, we did not specify any command, a default bash command is run on startup. CREATED: This field mentions the time when the container is started. STATUS: This field gives us a status of the container. In our case, we see the status code as being Exited (0) 10. This signifies that the ubuntu container was started, and is now shut down and is not running. The STATUS field helps us figure out the current status of a Docker container once it is started, and it can take different values, ranging from Creating ... to Up ..., which indicates that the container is either starting up or it is running for the amount of time mentioned after the Up string, respectively. PORTS: This field gives a list of ports that are to be exposed from inside the Docker container to the local user’s machine, so that the local user can access the port outside of Docker’s network NAMES: This field outputs the name that the docker container has when it is running. The name of a Docker container when it is run is also generated at random everytime a Docker container is started, but unlike the CONTAINER ID field, the name can be controlled and kept static for a particular Docker container. So, these are all the fields that are showed by the docker ps -a command. Now let’s start tampering with the docker run command to get a bit more out of the containers when we run them.\nPassing arguments to docker run command In the previous step, we just used the docker run command out of the box on the Ubuntu image. However, that did not give us much, not even a friendly terminal to let us inside the container that is running. Let’s now try to get inside the Ubuntu container to check what it has.\nTo do this, we first need to make the Ubuntu container execute a different command at runtime when it is started. For this, we can pass additional arguments to the docker run command in the terminal as follows:\ndocker run ubuntu sleep 3600 The sleep command that we pass is not a Docker argument, but a Linux system argument.\nTip: You can check more about the sleep command by running man sleep in your terminal (Only works for Linux-based OS like Ubuntu or MacOS)\nThe sleep command will override the default bash command from the Ubuntu container, and make the container sleep for the 3600 seconds 60 minutes. That should give us enough time to check what is inside the container.\nSo, once we have run the above command, we should see that the terminal does not exit like in the initial docker run command, but is in a way just stuck. However, if you open a new terminal and list all the containers with docker ps -a, we should now see the following:\n\u003e docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8ec5ceccbd72 ubuntu \"sleep 3600\" 3 seconds ago Up 1 second fervent_mclaren Notice how in the STATUS field it now shows Up 1 second. And also take a look COMMAND section to see that it now shows sleep 3600 as the command instead of bash like the previous case. That means the command that we passed while starting the container worked, and is executed as soon as the Ubuntu container is started. Let us now see what is inside the Ubuntu container.\nGoing inside a running container Now that the ubuntu container is running, we can look inside it. The default method to look what is inside a container is to get a terminal, and we can do the same for the ubuntu container. To get a terminal inside the container, we can run the following command:\n\u003e docker exec -it The exec command is used to run a command inside a running container. And to let Docker know which container we want to choose to execute the command, we need to pass an above, which can either be the NAME of the container or the CONTAINER ID. Let’s pass the CONTAINER ID for now, but we can pass NAME in exactly the same way.\nPro Tip: For passing the CONTAINER ID as an identifier for the exec command, we do not need to pass the full container id. Instead, we can just pass the first 3 characters of the CONTAINER ID to the exec command, and it will still be executed inside the correct running container.\nTo execute and get a shell inside the running container, run the following command:\ndocker exec -it 8ec bash Please make sure to pass the correct first 3 characters from your CONTAINER ID, since every CONTAINER ID is randomly generated, and your CONTAINER ID will not be the same as mine.\nOnce we run the above command in a new terminal, we should see the following output:\n\u003e docker exec -it 8ec bash root@8ec5ceccbd72:/# Well, well. We are now inside our running Docker container!!!🐕\nWe can now ls to check what files/directories the container has, and we can look around inside them as part of exploration. Let’s now see how we can give a name to a Docker container when we run it, and why is it useful.\nSome tips for running Docker containers It is very beneficial to give your Docker container a name, since doing so will always maintain a streamlined process of seeing inside the container and accessing it for checking your processes. This can be done by passing in the --name flag to the docker run command, which is a Docker flag unlike the sleep command we saw earlier. Let’s execute the following command in the terminal: docker run --name my_ubuntu_image ubuntu sleep 1000 You can pass either my_ubutu_image as the name of your container, or you can get creative and pass something that you like as a name for your Docker container. Once we run the above command, you can open a new terminal and check running containers with docker ps -a. Once you do, you should now see something like the following output:\n\u003e docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f04164a6395f ubuntu \"sleep 1000\" 3 seconds ago Up 1 second my_ubuntu_image Notice how the docker container now has in the NAMES field the name my_ubuntu_image, or whatever name you passed along in the --name flag. Now if you want to exec inside the running container, instead of passing the CONTAINER ID, we can pass the name of the container and it will go inside. Let’s try this out with docker exec -it my_ubuntu_image bash to get bash inside the docker container. You should definitely see something like the following:\n\u003e docker exec -it my_ubuntu_image bash root@f04164a6395f:/# Now we can always refer to our container while running commands with its name.\nNow that we have a Ubuntu container running, we need to know how to stop it. We need to stop old containers before running new ones, since Docker does not let us run two containers with the same name twice. To check this, run the following command again in a new terminal: docker run --name my_ubuntu_image ubuntu sleep 1000 You should get the following error message:\n\u003e docker run --name my_ubuntu_image ubuntu docker: Error response from daemon: Conflict. The container name \"/my_ubuntu_image\" is already in use by container \"f04164a6395f2c472bc5c6f6e59e304baa793b5d7edf106066e0764b51e1ad5d\". You have to remove (or rename) that container to be able to reuse that name. The error message tells us that there is a conflict with the container name, since we are already running a Ubuntu container with the same name. To rerun a new container with the same name, we first need to stop the one that is running currently. For this, we need to run the following command in a new terminal:\n\u003e docker stop my_ubuntu_image Once you run this command, the terminal will be back after the command is executed successfully, and if you now get a list of all the containers, you should see the following:\n\u003e docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES f04164a6395f ubuntu \"sleep 1000\" 12 minutes ago Exited (137) 9 seconds ago my_ubuntu_image As you can see, the STATUS field now shows Exited ... under it instead of the previously shown Up for x seconds. This means that our Ubuntu container has stopped running, and we are ready to start another container with the same desired name.\nAs per the above step, you now know how to stop a docker container. However, if you run the container again, you will still get the same error message with the name conflict as before. That is because docker not only needs you to stop the container, but to completely remove it before starting a new container. To do this, we can run the following command in a new terminal: docker system prune You should then show the following prompt in your terminal window:\n\u003e docker system prune WARNING! This will remove: - all stopped containers - all networks not used by at least one container - all dangling images - all dangling build cache Are you sure you want to continue? [y/N] docker system prune simply removes all the unnecessary data from your Docker environment, like stopped containers, containers that could not start correctly, or cache that a container created on your machine when it was started. In the above prompt, type y and press enter to let docker clear all stopped containers and the data related to them. Once this is successful, you should see a message as follows:\nDeleted Containers: f04164a6395f2c472bc5c6f6e59e304baa793b5d7edf106066e0764b51e1ad5d Total reclaimed space: 0B This message indicates that all the stopped containers are now removed, alongwith the caches that they had created when started. To check if there are any containers still, you can run docker ps -a.\nIf you want to manually remove only one specific container from the stopped containers afters stopping it, you can run the following command instead:\ndocker rm This will remove only the container whose name or id you passed.\nThe methodology of running containers from pre-built docker images can be extended to running custom images as containers that we create according to the previous post, or any custom container of your choice. All the list of commands remain the same, only the pre-built ubuntu image from the above commands needs to be replaced with your own custom image.\nRunning multiple containers and make them interact with each other So far, we have seen how to run a single image as a container, give it a name, pass some commands to override the default commands, how to stop and remove it. However, large pieces of software are rarely built on only one running container, and there are always many containers handling one specific task of the software independent of other tasks that are run by the software.\nFor this, we need to run multiple containers at once, and these containers also need to be able to interact with each other in order to make the software run successfully. Once simple examples where different containers can be run to do different tasks is run a PostgreSQL database to store some results from an API, a container to run the API itself, and a pgAdmin UI tool to interact with the database to check if the data that the API returns are being stored successfully inside the postgreSQL database. This sounds like a very general purpose use-case that many companies have in common, and this can be managed very efficiently via docker containers. We will see more about this in the next post of Docker Compose files, which allows us to run multiple containers at once.\n","wordCount":"2788","inLanguage":"en","image":"https://diginomica.com/sites/default/files/images/2017-09/docker-container.jpg","datePublished":"2022-08-10T04:17:32Z","dateModified":"2022-08-10T04:17:32Z","author":{"@type":"Person","name":"Tanmay"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://tanmaychimurkar.github.io/posts/docker/docker_compose/"},"publisher":{"@type":"Organization","name":"Tanmay's Blog","logo":{"@type":"ImageObject","url":"https://tanmaychimurkar.github.io/favicon.ico"}}}</script></head><body class=dark id=top><script>localStorage.getItem("pref-theme")==="light"&&document.body.classList.remove("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://tanmaychimurkar.github.io accesskey=h title="Tanmay's Blog (Alt + H)">Tanmay's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://tanmaychimurkar.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://tanmaychimurkar.github.io/categories title=Categories><span>Categories</span></a></li><li><a href=https://tanmaychimurkar.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://tanmaychimurkar.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://tanmaychimurkar.github.io>Home</a>&nbsp;»&nbsp;<a href=https://tanmaychimurkar.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://tanmaychimurkar.github.io/posts/docker/>Docker</a></div><h1 class=post-title>Docker Container and docker-compose</h1><div class=post-description>This post goes over the usage of Docker container, how to run them, and how to create a compose file so that many Docker images can interact with each other</div><div class=post-meta><span title='2022-08-10 04:17:32 +0000 UTC'>August 10, 2022</span>&nbsp;·&nbsp;14 min&nbsp;·&nbsp;Tanmay&nbsp;|&nbsp;<a href=https://github.com/tanmaychimurkar/tanmaychimurkar.github.io/tree/main/content/posts/docker/docker_compose.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><figure class=entry-cover><img loading=lazy src=https://diginomica.com/sites/default/files/images/2017-09/docker-container.jpg alt=Docker><p>The Docker container being run by the Dockerfile inside</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#what-are-they aria-label="What are they?">What are they?</a></li><li><a href=#running-a-container aria-label="Running a Container">Running a Container</a><ul><li><a href=#docker-ps-command aria-label="docker ps command"><code>docker ps</code> command</a></li><li><a href=#passing-arguments-to-docker-run-command aria-label="Passing arguments to docker run command">Passing arguments to <code>docker run</code> command</a></li><li><a href=#going-inside-a-running-container aria-label="Going inside a running container">Going inside a running container</a></li><li><a href=#some-tips-for-running-docker-containers aria-label="Some tips for running Docker containers">Some tips for running Docker containers</a></li></ul></li><li><a href=#running-multiple-containers-and-make-them-interact-with-each-other aria-label="Running multiple containers and make them interact with each other">Running multiple containers and make them interact with each other</a></li></ul></div></details></div><div class=post-content><h2 id=what-are-they>What are they?<a hidden class=anchor aria-hidden=true href=#what-are-they>#</a></h2><p>In the <a href=https://tanmaychimurkar.github.io/posts/docker/docker_images/ title="Docker Images">previous</a> post, we saw how to find Docker images form the <a href=https://hub.docker.com/>DockerHub</a>, and also how to create our own Docker image that <code>executes</code> a function. In this post, we will go more over the execution part of Docker, mainly about how to run a Docker image as a container.</p><p><a href=https://www.docker.com/resources/what-container/>Docker Containers</a> are Docker images that become containers at run time. Docker containers are short pieces of software that runs an application quickly, as a lightweight standalone package. The containers need an engine to run, and this is the <a href=https://docs.docker.com/engine/>Docker Engine</a>.</p><p>Basically, Docker containers make it easier to decentralize a large piece of software such that it can run in isolated environments, and they are what we can refer to as <code>microservices</code>. So in this part of the post, we will be running our first use case of <code>microservices</code>. We will start with running a single Docker image first, then we will combine many Docker images to run together so that they can interact with each other and run the whole software.</p><h2 id=running-a-container>Running a Container<a hidden class=anchor aria-hidden=true href=#running-a-container>#</a></h2><p>In the <a href=https://tanmaychimurkar.github.io/posts/docker/docker_images/ title="Docker Images">previous</a> post, we saw how we can either pull a pre-built Docker image from the DockerHub, or create our own custom image. We saw at the end that we had to <code>run</code> a specific command in the terminal to get the output from a Docker image. The commands that we ran in the previous post ran the Docker image, and during runtime, it created a Docker container that runs the piece of code that we put inside our own image or the outputs from a pre-built image from the DockerHub.</p><p>If you followed along with the <a href=https://tanmaychimurkar.github.io/posts/docker/docker_images/ title="Docker Images">previous</a> post, you should now see the <code>Ubuntu</code> image in the terminal when you execute the below command in your terminal.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt; docker images
</span></span><span class=line><span class=cl>REPOSITORY          TAG       IMAGE ID       CREATED         SIZE
</span></span><span class=line><span class=cl>custom_image        latest    432ba341135f   <span class=m>4</span> weeks ago     932MB
</span></span><span class=line><span class=cl>ubuntu              latest    6b7dfa7e8fdb   <span class=m>5</span> weeks ago     77.8MB
</span></span></code></pre></div><p>In case you did not follow the previous post, we can run the following command in the terminal first to pull a Docker image and then continue:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker pull ubuntu:latest 
</span></span></code></pre></div><p>Now we are ready to proceed. To start the Docker container, we can start by typing the following command in the terminal</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run ubuntu
</span></span></code></pre></div><p>If all is correct, you should see, well nothing. But why is that? We just ran our <code>Ubuntu</code> image as a Docker container, but we don&rsquo;t see anything on the terminal when we run it.</p><h3 id=docker-ps-command><code>docker ps</code> command<a hidden class=anchor aria-hidden=true href=#docker-ps-command>#</a></h3><p>To check whether a particular image is successfully run or not, we need to execute the following command in the terminal:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker ps
</span></span></code></pre></div><p>The <a href=https://docs.docker.com/engine/reference/commandline/ps/><code>docker ps</code></a> command lists all the containers. So if you ran the <code>Ubuntu</code> image as per the previous step, then the <code>docker ps</code> command should show that the <code>Ubuntu</code> container is running. Let&rsquo;s try to check if that is the case. In the terminal, execute the following command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker ps
</span></span></code></pre></div><p>However, the output we see in the terminal should be the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt; docker ps
</span></span><span class=line><span class=cl>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
</span></span></code></pre></div><p>Hmm, weird right? The documentation says that the <code>docker ps</code> command gives us a list of the containers. But we do not see anything in the terminal. This is because the <code>docker ps</code> command only list the containers that are <code>running</code> by default. And for our <code>Ubuntu</code> image, we did not give any specific command to run when we started the container via the <code>docker run</code> command. Which is why it is not showing up under the <code>docker ps</code> command. To check if the container was ranning when we started it, we need to pass the <code>-a</code> flag to the <code>docker ps</code> command. Let&rsquo;s run the following command in the terminal to check this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt; docker ps -a
</span></span><span class=line><span class=cl>CONTAINER ID   IMAGE                 COMMAND                  CREATED          STATUS                      PORTS     NAMES
</span></span><span class=line><span class=cl>4c42acd7b1cd   ubuntu                <span class=s2>&#34;bash&#34;</span>                   <span class=m>10</span> minutes ago   Exited <span class=o>(</span>0<span class=o>)</span> <span class=m>10</span> minutes ago             condescending_villani
</span></span></code></pre></div><p>We should see something like above in the terminal, with a different string under the <code>NAMES</code> and the <code>CONTAINER ID</code> column. Let&rsquo;s see what terms shown in the output of the <code>docker ps -a</code> command mean.</p><p>Below is a list explaining what each of the terms given in the output above mean:</p><ol><li><code>CONTAINER ID</code>: This column lists the id that a Docker container is given when it is run. This is a random id that is generated everytime a Docker container is run. If we run the same Docker image multiple times to start containers, it is very unlikely that the <code>CONTAINER ID</code> will be the same across different containers.</li><li><code>IMAGE</code>: This column gives the name of the Docker image that was used to start the Docker container. In our case, since we started the container using the command <code>docker run ubuntu</code> in the terminal, the <code>IMAGE</code> section correctly lists the <code>ubuntu</code> image in its run.</li><li><code>COMMAND</code>: This column lists the default command that is run when the Docker container is started. Since for the case of the <code>ubuntu</code> container, we did not specify any command, a default <code>bash</code> command is run on startup.</li><li><code>CREATED</code>: This field mentions the time when the container is started.</li><li><code>STATUS</code>: This field gives us a status of the container. In our case, we see the status code as being <code>Exited (0) 10</code>. This signifies that the <code>ubuntu</code> container was started, and is now shut down and is not running. The <code>STATUS</code> field helps us figure out the current status of a Docker container once it is started, and it can take different values, ranging from <code>Creating ...</code> to <code>Up ...</code>, which indicates that the container is either starting up or it is running for the amount of time mentioned after the <code>Up</code> string, respectively.</li><li><code>PORTS</code>: This field gives a list of ports that are to be exposed from inside the Docker container to the local user&rsquo;s machine, so that the local user can access the port outside of Docker&rsquo;s network</li><li><code>NAMES</code>: This field outputs the name that the docker container has when it is running. The name of a Docker container when it is run is also generated at random everytime a Docker container is started, but unlike the <code>CONTAINER ID</code> field, the name can be controlled and kept static for a particular Docker container.</li></ol><p>So, these are all the fields that are showed by the <code>docker ps -a</code> command. Now let&rsquo;s start tampering with the <code>docker run</code> command to get a bit more out of the containers when we run them.</p><h3 id=passing-arguments-to-docker-run-command>Passing arguments to <code>docker run</code> command<a hidden class=anchor aria-hidden=true href=#passing-arguments-to-docker-run-command>#</a></h3><p>In the previous step, we just used the <code>docker run</code> command out of the box on the <code>Ubuntu</code> image. However, that did not give us much, not even a friendly terminal to let us inside the container that is running. Let&rsquo;s now try to get inside the <code>Ubuntu</code> container to check what it has.</p><p>To do this, we first need to make the <code>Ubuntu</code> container execute a different command at runtime when it is started. For this, we can pass additional arguments to the <code>docker run</code> command in the terminal as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run ubuntu sleep <span class=m>3600</span>
</span></span></code></pre></div><p>The <code>sleep</code> command that we pass is not a Docker argument, but a <code>Linux</code> system argument.</p><p><code>Tip</code>: You can check more about the sleep command by running <code>man sleep</code> in your terminal (Only works for Linux-based OS like Ubuntu or MacOS)</p><p>The <code>sleep</code> command will override the default <code>bash</code> command from the <code>Ubuntu</code> container, and make the container sleep for the 3600 seconds 60 minutes. That should give us enough time to check what is inside the container.</p><p>So, once we have run the above command, we should see that the terminal does not exit like in the initial <code>docker run</code> command, but is in a way just stuck. However, if you open a new terminal and list all the containers with <code>docker ps -a</code>, we should now see the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt; docker ps -a
</span></span><span class=line><span class=cl>CONTAINER ID   IMAGE     COMMAND        CREATED         STATUS        PORTS     NAMES
</span></span><span class=line><span class=cl>8ec5ceccbd72   ubuntu    <span class=s2>&#34;sleep 3600&#34;</span>   <span class=m>3</span> seconds ago   Up <span class=m>1</span> second             fervent_mclaren
</span></span></code></pre></div><p>Notice how in the <code>STATUS</code> field it now shows <code>Up 1 second</code>. And also take a look <code>COMMAND</code> section to see that it now shows <code>sleep 3600</code> as the command instead of <code>bash</code> like the previous case. That means the command that we passed while starting the container worked, and is executed as soon as the <code>Ubuntu</code> container is started. Let us now see what is inside the <code>Ubuntu</code> container.</p><h3 id=going-inside-a-running-container>Going inside a running container<a hidden class=anchor aria-hidden=true href=#going-inside-a-running-container>#</a></h3><p>Now that the <code>ubuntu</code> container is running, we can look inside it. The default method to look what is inside a container is to get a terminal, and we can do the same for the <code>ubuntu</code> container. To get a terminal inside the container, we can run the following command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt; docker <span class=nb>exec</span> -it &lt;identifier&gt;
</span></span></code></pre></div><p>The <a href=https://docs.docker.com/engine/reference/commandline/exec/><code>exec</code></a> command is used to run a command inside a running container. And to let Docker know which container we want to choose to execute the command, we need to pass an <code>&lt;identifier></code> above, which can either be the <code>NAME</code> of the container or the <code>CONTAINER ID</code>. Let&rsquo;s pass the <code>CONTAINER ID</code> for now, but we can pass <code>NAME</code> in exactly the same way.</p><p><code>Pro Tip</code>: For passing the <code>CONTAINER ID</code> as an identifier for the <code>exec</code> command, we do not need to pass the full container id. Instead, we can just pass the first 3 characters of the <code>CONTAINER ID</code> to the exec command, and it will still be executed inside the correct running container.</p><p>To execute and get a shell inside the running container, run the following command:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker <span class=nb>exec</span> -it 8ec bash
</span></span></code></pre></div><p>Please make sure to pass the correct first 3 characters from your <code>CONTAINER ID</code>, since every <code>CONTAINER ID</code> is randomly generated, and your <code>CONTAINER ID</code> will not be the same as mine.</p><p>Once we run the above command in a new terminal, we should see the following output:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt; docker <span class=nb>exec</span> -it 8ec bash
</span></span><span class=line><span class=cl>root@8ec5ceccbd72:/# 
</span></span></code></pre></div><p>Well, well. We are now inside our running Docker container!!!🐕</p><p>We can now <code>ls</code> to check what files/directories the container has, and we can look around inside them as part of exploration. Let&rsquo;s now see how we can give a name to a Docker container when we run it, and why is it useful.</p><h3 id=some-tips-for-running-docker-containers>Some tips for running Docker containers<a hidden class=anchor aria-hidden=true href=#some-tips-for-running-docker-containers>#</a></h3><ol><li>It is very beneficial to give your Docker container a name, since doing so will always maintain a streamlined process of seeing inside the container and accessing it for checking your processes. This can be done by passing in the <code>--name</code> flag to the <code>docker run</code> command, which is a <code>Docker</code> flag unlike the <code>sleep</code> command we saw earlier. Let&rsquo;s execute the following command in the terminal:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run  --name my_ubuntu_image ubuntu sleep <span class=m>1000</span>
</span></span></code></pre></div><p>You can pass either <code>my_ubutu_image</code> as the name of your container, or you can get creative and pass something that you like as a name for your Docker container. Once we run the above command, you can open a new terminal and check running containers with <code>docker ps -a</code>. Once you do, you should now see something like the following output:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt; docker ps -a
</span></span><span class=line><span class=cl>CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES
</span></span><span class=line><span class=cl>f04164a6395f   ubuntu    <span class=s2>&#34;sleep 1000&#34;</span>             <span class=m>3</span> seconds ago    Up <span class=m>1</span> second               my_ubuntu_image
</span></span></code></pre></div><p>Notice how the docker container now has in the <code>NAMES</code> field the name <code>my_ubuntu_image</code>, or whatever name you passed along in the <code>--name</code> flag. Now if you want to <code>exec</code> inside the running container, instead of passing the <code>CONTAINER ID</code>, we can pass the name of the container and it will go inside. Let&rsquo;s try this out with <code>docker exec -it my_ubuntu_image bash</code> to get bash inside the docker container. You should definitely see something like the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt; docker <span class=nb>exec</span> -it my_ubuntu_image bash
</span></span><span class=line><span class=cl>root@f04164a6395f:/# 
</span></span></code></pre></div><p>Now we can always refer to our container while running commands with its name.</p><ol start=2><li>Now that we have a <code>Ubuntu</code> container running, we need to know how to stop it. We need to stop old containers before running new ones, since Docker does not let us run two containers with the same name twice. To check this, run the following command again in a new terminal:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run  --name my_ubuntu_image ubuntu sleep <span class=m>1000</span>
</span></span></code></pre></div><p>You should get the following error message:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt; docker run --name my_ubuntu_image ubuntu
</span></span><span class=line><span class=cl>docker: Error response from daemon: Conflict. The container name <span class=s2>&#34;/my_ubuntu_image&#34;</span> is already in use by container <span class=s2>&#34;f04164a6395f2c472bc5c6f6e59e304baa793b5d7edf106066e0764b51e1ad5d&#34;</span>. You have to remove <span class=o>(</span>or rename<span class=o>)</span> that container to be able to reuse that name.
</span></span></code></pre></div><p>The error message tells us that there is a conflict with the container name, since we are already running a <code>Ubuntu</code> container with the same name. To rerun a new container with the same name, we first need to stop the one that is running currently. For this, we need to run the following command in a new terminal:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt; docker stop my_ubuntu_image
</span></span></code></pre></div><p>Once you run this command, the terminal will be back after the command is executed successfully, and if you now get a list of all the containers, you should see the following:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt; docker ps -a
</span></span><span class=line><span class=cl>CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS                       PORTS     NAMES
</span></span><span class=line><span class=cl>f04164a6395f   ubuntu    <span class=s2>&#34;sleep 1000&#34;</span>             <span class=m>12</span> minutes ago   Exited <span class=o>(</span>137<span class=o>)</span> <span class=m>9</span> seconds ago             my_ubuntu_image
</span></span></code></pre></div><p>As you can see, the <code>STATUS</code> field now shows <code>Exited ...</code> under it instead of the previously shown <code>Up for x seconds</code>. This means that our <code>Ubuntu</code> container has stopped running, and we are ready to start another container with the same desired name.</p><ol start=3><li>As per the above step, you now know how to stop a docker container. However, if you run the container again, you will still get the same error message with the <code>name conflict</code> as before. That is because docker not only needs you to stop the container, but to completely remove it before starting a new container. To do this, we can run the following command in a new terminal:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker system prune
</span></span></code></pre></div><p>You should then show the following prompt in your terminal window:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>&gt; docker system prune
</span></span><span class=line><span class=cl>WARNING! This will remove:
</span></span><span class=line><span class=cl>  - all stopped containers
</span></span><span class=line><span class=cl>  - all networks not used by at least one container
</span></span><span class=line><span class=cl>  - all dangling images
</span></span><span class=line><span class=cl>  - all dangling build cache
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Are you sure you want to <span class=k>continue</span>? <span class=o>[</span>y/N<span class=o>]</span> 
</span></span></code></pre></div><p><a href=https://docs.docker.com/engine/reference/commandline/system_prune/><code>docker system prune</code></a> simply removes all the unnecessary data from your Docker environment, like stopped containers, containers that could not start correctly, or cache that a container created on your machine when it was started. In the above prompt, type <code>y</code> and press enter to let docker clear all stopped containers and the data related to them. Once this is successful, you should see a message as follows:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>Deleted Containers:
</span></span><span class=line><span class=cl>f04164a6395f2c472bc5c6f6e59e304baa793b5d7edf106066e0764b51e1ad5d
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Total reclaimed space: 0B
</span></span></code></pre></div><p>This message indicates that all the stopped containers are now removed, alongwith the caches that they had created when started. To check if there are any containers still, you can run
<code>docker ps -a</code>.</p><p>If you want to manually remove only one specific container from the stopped containers afters stopping it, you can run the following command instead:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker rm &lt;container name or id&gt;
</span></span></code></pre></div><p>This will remove only the container whose name or id you passed.</p><p>The methodology of running containers from pre-built docker images can be extended to running custom images as containers that we create according to the <a href=https://tanmaychimurkar.github.io/posts/docker/docker_images/ title="Docker Images">previous</a> post, or any custom container of your choice. All the list of commands remain the same, only the pre-built <code>ubuntu</code> image from the above commands needs to be replaced with your own custom image.</p><h2 id=running-multiple-containers-and-make-them-interact-with-each-other>Running multiple containers and make them interact with each other<a hidden class=anchor aria-hidden=true href=#running-multiple-containers-and-make-them-interact-with-each-other>#</a></h2><p>So far, we have seen how to run a single image as a container, give it a name, pass some commands to override the default commands, how to stop and remove it. However, large pieces of software are rarely built on only one running container, and there are always many containers handling one specific task of the software independent of other tasks that are run by the software.</p><p>For this, we need to run multiple containers at once, and these containers also need to be able to interact with each other in order to make the software run successfully. Once simple examples where different containers can be run to do different tasks is run a <a href=https://www.postgresql.org/><code>PostgreSQL</code></a> database to store some results from an API, a container to run the API itself, and a <a href=https://www.pgadmin.org/>pgAdmin</a> UI tool to interact with the database to check if the data that the API returns are being stored successfully inside the postgreSQL database. This sounds like a very general purpose use-case that many companies have in common, and this can be managed very efficiently via docker containers. We will see more about this in the <a href=https://tanmaychimurkar.github.io/posts/docker/docker_compose/ title="Docker Compose">next</a> post of <code>Docker Compose</code> files, which allows us to run multiple containers at once.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://tanmaychimurkar.github.io/tags/docker/>Docker</a></li><li><a href=https://tanmaychimurkar.github.io/tags/microservices/>microservices</a></li></ul><nav class=paginav><a class=prev href=https://tanmaychimurkar.github.io/posts/docker/docker_images/><span class=title>« Prev</span><br><span>Docker Images and DockerFile</span></a>
<a class=next href=https://tanmaychimurkar.github.io/posts/docker/docker_containers/><span class=title>Next »</span><br><span>Docker Containers</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Docker Container and docker-compose on twitter" href="https://twitter.com/intent/tweet/?text=Docker%20Container%20and%20docker-compose&url=https%3a%2f%2ftanmaychimurkar.github.io%2fposts%2fdocker%2fdocker_compose%2f&hashtags=Docker%2cmicroservices"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker Container and docker-compose on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2ftanmaychimurkar.github.io%2fposts%2fdocker%2fdocker_compose%2f&title=Docker%20Container%20and%20docker-compose&summary=Docker%20Container%20and%20docker-compose&source=https%3a%2f%2ftanmaychimurkar.github.io%2fposts%2fdocker%2fdocker_compose%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker Container and docker-compose on reddit" href="https://reddit.com/submit?url=https%3a%2f%2ftanmaychimurkar.github.io%2fposts%2fdocker%2fdocker_compose%2f&title=Docker%20Container%20and%20docker-compose"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker Container and docker-compose on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftanmaychimurkar.github.io%2fposts%2fdocker%2fdocker_compose%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker Container and docker-compose on whatsapp" href="https://api.whatsapp.com/send?text=Docker%20Container%20and%20docker-compose%20-%20https%3a%2f%2ftanmaychimurkar.github.io%2fposts%2fdocker%2fdocker_compose%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Docker Container and docker-compose on telegram" href="https://telegram.me/share/url?text=Docker%20Container%20and%20docker-compose&url=https%3a%2f%2ftanmaychimurkar.github.io%2fposts%2fdocker%2fdocker_compose%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://tanmaychimurkar.github.io>Tanmay's Blog</a></span>
<span>Made with &#128151; with
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>